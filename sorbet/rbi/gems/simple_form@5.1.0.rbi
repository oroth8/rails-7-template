# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `simple_form` gem.
# Please instead update this file by running `bin/tapioca gem simple_form`.

module ActionView::Helpers
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper

  mixes_in_class_methods ::ActionView::Helpers::UrlHelper::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::SanitizeHelper::ClassMethods

  class << self
    def eager_load!; end
  end
end

# A +FormBuilder+ object is associated with a particular model object and
# allows you to generate fields associated with the model object. The
# +FormBuilder+ object is yielded when using +form_for+ or +fields_for+.
# For example:
#
#   <%= form_for @person do |person_form| %>
#     Name: <%= person_form.text_field :name %>
#     Admin: <%= person_form.check_box :admin %>
#   <% end %>
#
# In the above block, a +FormBuilder+ object is yielded as the
# +person_form+ variable. This allows you to generate the +text_field+
# and +check_box+ fields by specifying their eponymous methods, which
# modify the underlying template and associates the <tt>@person</tt> model object
# with the form.
#
# The +FormBuilder+ object can be thought of as serving as a proxy for the
# methods in the +FormHelper+ module. This class, however, allows you to
# call methods with the model object you are building the form for.
#
# You can create your own custom FormBuilder templates by subclassing this
# class. For example:
#
#   class MyFormBuilder < ActionView::Helpers::FormBuilder
#     def div_radio_button(method, tag_value, options = {})
#       @template.content_tag(:div,
#         @template.radio_button(
#           @object_name, method, tag_value, objectify_options(options)
#         )
#       )
#     end
#   end
#
# The above code creates a new method +div_radio_button+ which wraps a div
# around the new radio button. Note that when options are passed in, you
# must call +objectify_options+ in order for the model object to get
# correctly passed to the method. If +objectify_options+ is not called,
# then the newly created helper will not be linked back to the model.
#
# The +div_radio_button+ code from above can now be used as follows:
#
#   <%= form_for @person, :builder => MyFormBuilder do |f| %>
#     I am a child: <%= f.div_radio_button(:admin, "child") %>
#     I am an adult: <%= f.div_radio_button(:admin, "adult") %>
#   <% end -%>
#
# The standard set of helper methods for form building are located in the
# +field_helpers+ class attribute.
class ActionView::Helpers::FormBuilder
  include ::SimpleForm::ActionViewExtensions::Builder

  # @return [FormBuilder] a new instance of FormBuilder
  def initialize(object_name, object, template, options); end

  # Add the submit button for the given form. When no value is given, it checks
  # if the object is a new resource or not to create the proper label:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.button %>
  #   <% end %>
  #
  # In the example above, if <tt>@post</tt> is a new record, it will use "Create Post" as
  # button label; otherwise, it uses "Update Post".
  #
  # Those labels can be customized using I18n under the +helpers.submit+ key
  # (the same as submit helper) and using <tt>%{model}</tt> for translation interpolation:
  #
  #   en:
  #     helpers:
  #       submit:
  #         create: "Create a %{model}"
  #         update: "Confirm changes to %{model}"
  #
  # It also searches for a key specific to the given object:
  #
  #   en:
  #     helpers:
  #       submit:
  #         post:
  #           create: "Add %{model}"
  #
  # ==== Examples
  #   button("Create post")
  #   # => <button name='button' type='submit'>Create post</button>
  #
  #   button(:draft, value: true)
  #   # => <button id="post_draft" name="post[draft]" value="true" type="submit">Create post</button>
  #
  #   button do
  #     content_tag(:strong, 'Ask me!')
  #   end
  #   # => <button name='button' type='submit'>
  #   #      <strong>Ask me!</strong>
  #   #    </button>
  #
  #   button do |text|
  #     content_tag(:strong, text)
  #   end
  #   # => <button name='button' type='submit'>
  #   #      <strong>Create post</strong>
  #   #    </button>
  #
  #   button(:draft, value: true) do
  #     content_tag(:strong, "Save as draft")
  #   end
  #   # =>  <button id="post_draft" name="post[draft]" value="true" type="submit">
  #   #       <strong>Save as draft</strong>
  #   #     </button>
  def button(value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns a checkbox tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). This object must be an instance object (@object) and not a local object.
  # It's intended that +method+ returns an integer and if that integer is above zero, then the checkbox is checked.
  # Additional options on the input tag can be passed as a hash with +options+. The +checked_value+ defaults to 1
  # while the default +unchecked_value+ is set to 0 which is convenient for boolean values.
  #
  # ==== Options
  #
  # * Any standard HTML attributes for the tag can be passed in, for example +:class+.
  # * <tt>:checked</tt> - +true+ or +false+ forces the state of the checkbox to be checked or not.
  # * <tt>:include_hidden</tt> - If set to false, the auxiliary hidden field described below will not be generated.
  #
  # ==== Gotcha
  #
  # The HTML specification says unchecked check boxes are not successful, and
  # thus web browsers do not send them. Unfortunately this introduces a gotcha:
  # if an +Invoice+ model has a +paid+ flag, and in the form that edits a paid
  # invoice the user unchecks its check box, no +paid+ parameter is sent. So,
  # any mass-assignment idiom like
  #
  #   @invoice.update(params[:invoice])
  #
  # wouldn't update the flag.
  #
  # To prevent this the helper generates an auxiliary hidden field before
  # every check box. The hidden field has the same name and its
  # attributes mimic an unchecked check box.
  #
  # This way, the client either sends only the hidden field (representing
  # the check box is unchecked), or both fields. Since the HTML specification
  # says key/value pairs have to be sent in the same order they appear in the
  # form, and parameters extraction gets the last occurrence of any repeated
  # key in the query string, that works for ordinary forms.
  #
  # Unfortunately that workaround does not work when the check box goes
  # within an array-like parameter, as in
  #
  #   <%= fields_for "project[invoice_attributes][]", invoice, index: nil do |form| %>
  #     <%= form.check_box :paid %>
  #     ...
  #   <% end %>
  #
  # because parameter name repetition is precisely what Rails seeks to distinguish
  # the elements of the array. For each item with a checked check box you
  # get an extra ghost item with only that attribute, assigned to "0".
  #
  # In that case it is preferable to either use +check_box_tag+ or to use
  # hashes instead of arrays.
  #
  # ==== Examples
  #
  #   # Let's say that @post.validated? is 1:
  #   check_box("validated")
  #   # => <input name="post[validated]" type="hidden" value="0" />
  #   #    <input checked="checked" type="checkbox" id="post_validated" name="post[validated]" value="1" />
  #
  #   # Let's say that @puppy.gooddog is "no":
  #   check_box("gooddog", {}, "yes", "no")
  #   # => <input name="puppy[gooddog]" type="hidden" value="no" />
  #   #    <input type="checkbox" id="puppy_gooddog" name="puppy[gooddog]" value="yes" />
  #
  #   # Let's say that @eula.accepted is "no":
  #   check_box("accepted", { class: 'eula_check' }, "yes", "no")
  #   # => <input name="eula[accepted]" type="hidden" value="no" />
  #   #    <input type="checkbox" class="eula_check" id="eula_accepted" name="eula[accepted]" value="yes" />
  def check_box(method, options = T.unsafe(nil), checked_value = T.unsafe(nil), unchecked_value = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::FormOptionsHelper#collection_check_boxes for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_check_boxes :author_ids, Author.all, :id, :name_with_initial %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_check_boxes(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Wraps ActionView::Helpers::FormOptionsHelper#collection_radio_buttons for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_radio_buttons :author_id, Author.all, :id, :name_with_initial %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_radio_buttons(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Wraps ActionView::Helpers::FormOptionsHelper#collection_select for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_select :person_id, Author.all, :id, :name_with_initial, prompt: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_select(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  def color_field(method, options = T.unsafe(nil)); end
  def date_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::DateHelper#date_select for form builders:
  #
  #   <%= form_for @person do |f| %>
  #     <%= f.date_select :birth_date %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def date_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  def datetime_field(method, options = T.unsafe(nil)); end
  def datetime_local_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::DateHelper#datetime_select for form builders:
  #
  #   <%= form_for @person do |f| %>
  #     <%= f.datetime_select :last_request_at %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def datetime_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  def email_field(method, options = T.unsafe(nil)); end

  # @return [Boolean]
  def emitted_hidden_id?; end

  def field_helpers; end
  def field_helpers=(_arg0); end
  def field_helpers?; end

  # Generate an HTML <tt>id</tt> attribute value for the given field
  #
  # Return the value generated by the <tt>FormBuilder</tt> for the given
  # attribute name.
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.label :title %>
  #     <%= f.text_field :title, aria: { describedby: f.field_id(:title, :error) } %>
  #     <%= tag.span("is blank", id: f.field_id(:title, :error) %>
  #   <% end %>
  #
  # In the example above, the <tt><input type="text"></tt> element built by
  # the call to <tt>FormBuilder#text_field</tt> declares an
  # <tt>aria-describedby</tt> attribute referencing the <tt><span></tt>
  # element, sharing a common <tt>id</tt> root (<tt>post_title</tt>, in this
  # case).
  def field_id(method, *suffixes, namespace: T.unsafe(nil), index: T.unsafe(nil)); end

  # Generate an HTML <tt>name</tt> attribute value for the given name and
  # field combination
  #
  # Return the value generated by the <tt>FormBuilder</tt> for the given
  # attribute name.
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.text_field :title, name: f.field_name(:title, :subtitle) %>
  #     <%# => <input type="text" name="post[title][subtitle]">
  #   <% end %>
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.field_tag :tag, name: f.field_name(:tag, multiple: true) %>
  #     <%# => <input type="text" name="post[tag][]">
  #   <% end %>
  def field_name(method, *methods, multiple: T.unsafe(nil), index: T.unsafe(nil)); end

  # See the docs for the ActionView::Helpers::FormHelper#fields helper method.
  def fields(scope = T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  # Creates a scope around a specific model object like form_for, but
  # doesn't create the form tags themselves. This makes fields_for suitable
  # for specifying additional model objects in the same form.
  #
  # Although the usage and purpose of +fields_for+ is similar to +form_for+'s,
  # its method signature is slightly different. Like +form_for+, it yields
  # a FormBuilder object associated with a particular model object to a block,
  # and within the block allows methods to be called on the builder to
  # generate fields associated with the model object. Fields may reflect
  # a model object in two ways - how they are named (hence how submitted
  # values appear within the +params+ hash in the controller) and what
  # default values are shown when the form the fields appear in is first
  # displayed. In order for both of these features to be specified independently,
  # both an object name (represented by either a symbol or string) and the
  # object itself can be passed to the method separately -
  #
  #   <%= form_for @person do |person_form| %>
  #     First name: <%= person_form.text_field :first_name %>
  #     Last name : <%= person_form.text_field :last_name %>
  #
  #     <%= fields_for :permission, @person.permission do |permission_fields| %>
  #       Admin?  : <%= permission_fields.check_box :admin %>
  #     <% end %>
  #
  #     <%= person_form.submit %>
  #   <% end %>
  #
  # In this case, the checkbox field will be represented by an HTML +input+
  # tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted
  # value will appear in the controller as <tt>params[:permission][:admin]</tt>.
  # If <tt>@person.permission</tt> is an existing record with an attribute
  # +admin+, the initial state of the checkbox when first displayed will
  # reflect the value of <tt>@person.permission.admin</tt>.
  #
  # Often this can be simplified by passing just the name of the model
  # object to +fields_for+ -
  #
  #   <%= fields_for :permission do |permission_fields| %>
  #     Admin?: <%= permission_fields.check_box :admin %>
  #   <% end %>
  #
  # ...in which case, if <tt>:permission</tt> also happens to be the name of an
  # instance variable <tt>@permission</tt>, the initial state of the input
  # field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.
  #
  # Alternatively, you can pass just the model object itself (if the first
  # argument isn't a string or symbol +fields_for+ will realize that the
  # name has been omitted) -
  #
  #   <%= fields_for @person.permission do |permission_fields| %>
  #     Admin?: <%= permission_fields.check_box :admin %>
  #   <% end %>
  #
  # and +fields_for+ will derive the required name of the field from the
  # _class_ of the model object, e.g. if <tt>@person.permission</tt>, is
  # of class +Permission+, the field will still be named <tt>permission[admin]</tt>.
  #
  # Note: This also works for the methods in FormOptionsHelper and
  # DateHelper that are designed to work with an object as base, like
  # FormOptionsHelper#collection_select and DateHelper#datetime_select.
  #
  # === Nested Attributes Examples
  #
  # When the object belonging to the current scope has a nested attribute
  # writer for a certain attribute, fields_for will yield a new scope
  # for that attribute. This allows you to create forms that set or change
  # the attributes of a parent object and its associations in one go.
  #
  # Nested attribute writers are normal setter methods named after an
  # association. The most common way of defining these writers is either
  # with +accepts_nested_attributes_for+ in a model definition or by
  # defining a method with the proper name. For example: the attribute
  # writer for the association <tt>:address</tt> is called
  # <tt>address_attributes=</tt>.
  #
  # Whether a one-to-one or one-to-many style form builder will be yielded
  # depends on whether the normal reader method returns a _single_ object
  # or an _array_ of objects.
  #
  # ==== One-to-one
  #
  # Consider a Person class which returns a _single_ Address from the
  # <tt>address</tt> reader method and responds to the
  # <tt>address_attributes=</tt> writer method:
  #
  #   class Person
  #     def address
  #       @address
  #     end
  #
  #     def address_attributes=(attributes)
  #       # Process the attributes hash
  #     end
  #   end
  #
  # This model can now be used with a nested fields_for, like so:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :address do |address_fields| %>
  #       Street  : <%= address_fields.text_field :street %>
  #       Zip code: <%= address_fields.text_field :zip_code %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # When address is already an association on a Person you can use
  # +accepts_nested_attributes_for+ to define the writer method for you:
  #
  #   class Person < ActiveRecord::Base
  #     has_one :address
  #     accepts_nested_attributes_for :address
  #   end
  #
  # If you want to destroy the associated model through the form, you have
  # to enable it first using the <tt>:allow_destroy</tt> option for
  # +accepts_nested_attributes_for+:
  #
  #   class Person < ActiveRecord::Base
  #     has_one :address
  #     accepts_nested_attributes_for :address, allow_destroy: true
  #   end
  #
  # Now, when you use a form element with the <tt>_destroy</tt> parameter,
  # with a value that evaluates to +true+, you will destroy the associated
  # model (e.g. 1, '1', true, or 'true'):
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :address do |address_fields| %>
  #       ...
  #       Delete: <%= address_fields.check_box :_destroy %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # ==== One-to-many
  #
  # Consider a Person class which returns an _array_ of Project instances
  # from the <tt>projects</tt> reader method and responds to the
  # <tt>projects_attributes=</tt> writer method:
  #
  #   class Person
  #     def projects
  #       [@project1, @project2]
  #     end
  #
  #     def projects_attributes=(attributes)
  #       # Process the attributes hash
  #     end
  #   end
  #
  # Note that the <tt>projects_attributes=</tt> writer method is in fact
  # required for fields_for to correctly identify <tt>:projects</tt> as a
  # collection, and the correct indices to be set in the form markup.
  #
  # When projects is already an association on Person you can use
  # +accepts_nested_attributes_for+ to define the writer method for you:
  #
  #   class Person < ActiveRecord::Base
  #     has_many :projects
  #     accepts_nested_attributes_for :projects
  #   end
  #
  # This model can now be used with a nested fields_for. The block given to
  # the nested fields_for call will be repeated for each instance in the
  # collection:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       <% if project_fields.object.active? %>
  #         Name: <%= project_fields.text_field :name %>
  #       <% end %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # It's also possible to specify the instance to be used:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <% @person.projects.each do |project| %>
  #       <% if project.active? %>
  #         <%= person_form.fields_for :projects, project do |project_fields| %>
  #           Name: <%= project_fields.text_field :name %>
  #         <% end %>
  #       <% end %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # Or a collection to be used:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects, @active_projects do |project_fields| %>
  #       Name: <%= project_fields.text_field :name %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # If you want to destroy any of the associated models through the
  # form, you have to enable it first using the <tt>:allow_destroy</tt>
  # option for +accepts_nested_attributes_for+:
  #
  #   class Person < ActiveRecord::Base
  #     has_many :projects
  #     accepts_nested_attributes_for :projects, allow_destroy: true
  #   end
  #
  # This will allow you to specify which models to destroy in the
  # attributes hash by adding a form element for the <tt>_destroy</tt>
  # parameter with a value that evaluates to +true+
  # (e.g. 1, '1', true, or 'true'):
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       Delete: <%= project_fields.check_box :_destroy %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # When a collection is used you might want to know the index of each
  # object into the array. For this purpose, the <tt>index</tt> method
  # is available in the FormBuilder object.
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       Project #<%= project_fields.index %>
  #       ...
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # Note that fields_for will automatically generate a hidden field
  # to store the ID of the record. There are circumstances where this
  # hidden field is not needed and you can pass <tt>include_id: false</tt>
  # to prevent fields_for from rendering it automatically.
  def fields_for(record_name, record_object = T.unsafe(nil), fields_options = T.unsafe(nil), &block); end

  # Returns a file upload input tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). Additional options on the input tag can be passed as a
  # hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example
  # shown.
  #
  # Using this method inside a +form_with+ block will set the enclosing form's encoding to <tt>multipart/form-data</tt>.
  #
  # ==== Options
  # * Creates standard HTML attributes for the tag.
  # * <tt>:disabled</tt> - If set to true, the user will not be able to use this input.
  # * <tt>:multiple</tt> - If set to true, *in most updated browsers* the user will be allowed to select multiple files.
  # * <tt>:include_hidden</tt> - When <tt>multiple: true</tt> and <tt>include_hidden: true</tt>, the field will be prefixed with an <tt><input type="hidden"></tt> field with an empty value to support submitting an empty collection of files.
  # * <tt>:accept</tt> - If set to one or multiple mime-types, the user will be suggested a filter when choosing a file. You still need to set up model validations.
  #
  # ==== Examples
  #   # Let's say that @user has avatar:
  #   file_field(:avatar)
  #   # => <input type="file" id="user_avatar" name="user[avatar]" />
  #
  #   # Let's say that @post has image:
  #   file_field(:image, :multiple => true)
  #   # => <input type="file" id="post_image" name="post[image][]" multiple="multiple" />
  #
  #   # Let's say that @post has attached:
  #   file_field(:attached, accept: 'text/html')
  #   # => <input accept="text/html" type="file" id="post_attached" name="post[attached]" />
  #
  #   # Let's say that @post has image:
  #   file_field(:image, accept: 'image/png,image/gif,image/jpeg')
  #   # => <input type="file" id="post_image" name="post[image]" accept="image/png,image/gif,image/jpeg" />
  #
  #   # Let's say that @attachment has file:
  #   file_field(:file, class: 'file_input')
  #   # => <input type="file" id="attachment_file" name="attachment[file]" class="file_input" />
  def file_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::FormOptionsHelper#grouped_collection_select for form builders:
  #
  #   <%= form_for @city do |f| %>
  #     <%= f.grouped_collection_select :country_id, @continents, :countries, :name, :id, :name %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  # Returns a hidden input tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). Additional options on the input tag can be passed as a
  # hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example
  # shown.
  #
  # ==== Examples
  #   # Let's say that @signup.pass_confirm returns true:
  #   hidden_field(:pass_confirm)
  #   # => <input type="hidden" id="signup_pass_confirm" name="signup[pass_confirm]" value="true" />
  #
  #   # Let's say that @post.tag_list returns "blog, ruby":
  #   hidden_field(:tag_list)
  #   # => <input type="hidden" id="post_tag_list" name="post[tag_list]" value="blog, ruby" />
  #
  #   # Let's say that @user.token returns "abcde":
  #   hidden_field(:token)
  #   # => <input type="hidden" id="user_token" name="user[token]" value="abcde" />
  def hidden_field(method, options = T.unsafe(nil)); end

  # Generate an HTML <tt>id</tt> attribute value.
  #
  # return the <tt><form></tt> element's <tt>id</tt> attribute.
  #
  #   <%= form_for @post do |f| %>
  #     <%# ... %>
  #
  #     <% content_for :sticky_footer do %>
  #       <%= form.button(form: f.id) %>
  #     <% end %>
  #   <% end %>
  #
  # In the example above, the <tt>:sticky_footer</tt> content area will
  # exist outside of the <tt><form></tt> element. By declaring the
  # <tt>form</tt> HTML attribute, we hint to the browser that the generated
  # <tt><button></tt> element should be treated as the <tt><form></tt>
  # element's submit button, regardless of where it exists in the DOM.
  def id; end

  # Returns the value of attribute index.
  def index; end

  # Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation
  # is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly.
  # Additional options on the label tag can be passed as a hash with +options+. These options will be tagged
  # onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to
  # target labels for radio_button tags (where the value is used in the ID of the input tag).
  #
  # ==== Examples
  #   label(:title)
  #   # => <label for="post_title">Title</label>
  #
  # You can localize your labels based on model and attribute names.
  # For example you can define the following in your locale (e.g. en.yml)
  #
  #   helpers:
  #     label:
  #       post:
  #         body: "Write your entire text here"
  #
  # Which then will result in
  #
  #   label(:body)
  #   # => <label for="post_body">Write your entire text here</label>
  #
  # Localization can also be based purely on the translation of the attribute-name
  # (if you are using ActiveRecord):
  #
  #   activerecord:
  #     attributes:
  #       post:
  #         cost: "Total cost"
  #
  #   label(:cost)
  #   # => <label for="post_cost">Total cost</label>
  #
  #   label(:title, "A short title")
  #   # => <label for="post_title">A short title</label>
  #
  #   label(:title, "A short title", class: "title_label")
  #   # => <label for="post_title" class="title_label">A short title</label>
  #
  #   label(:privacy, "Public Post", value: "public")
  #   # => <label for="post_privacy_public">Public Post</label>
  #
  #   label(:cost) do |translation|
  #     content_tag(:span, translation, class: "cost_label")
  #   end
  #   # => <label for="post_cost"><span class="cost_label">Total cost</span></label>
  #
  #   label(:cost) do |builder|
  #     content_tag(:span, builder.translation, class: "cost_label")
  #   end
  #   # => <label for="post_cost"><span class="cost_label">Total cost</span></label>
  #
  #   label(:cost) do |builder|
  #     content_tag(:span, builder.translation, class: [
  #       "cost_label",
  #       ("error_label" if builder.object.errors.include?(:cost))
  #     ])
  #   end
  #   # => <label for="post_cost"><span class="cost_label error_label">Total cost</span></label>
  #
  #   label(:terms) do
  #     raw('Accept <a href="/terms">Terms</a>.')
  #   end
  #   # => <label for="post_terms">Accept <a href="/terms">Terms</a>.</label>
  def label(method, text = T.unsafe(nil), options = T.unsafe(nil), &block); end

  def month_field(method, options = T.unsafe(nil)); end

  # Returns the value of attribute multipart.
  def multipart; end

  def multipart=(multipart); end

  # Returns the value of attribute multipart.
  def multipart?; end

  def number_field(method, options = T.unsafe(nil)); end

  # Returns the value of attribute object.
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  def object=(_arg0); end

  # Returns the value of attribute object_name.
  def object_name; end

  # Sets the attribute object_name
  #
  # @param value the value to set the attribute object_name to.
  def object_name=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def password_field(method, options = T.unsafe(nil)); end
  def phone_field(method, options = T.unsafe(nil)); end

  # Returns a radio button tag for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). If the current value of +method+ is +tag_value+ the
  # radio button will be checked.
  #
  # To force the radio button to be checked pass <tt>checked: true</tt> in the
  # +options+ hash. You may pass HTML options there as well.
  #
  #   # Let's say that @post.category returns "rails":
  #   radio_button("category", "rails")
  #   radio_button("category", "java")
  #   # => <input type="radio" id="post_category_rails" name="post[category]" value="rails" checked="checked" />
  #   #    <input type="radio" id="post_category_java" name="post[category]" value="java" />
  #
  #   # Let's say that @user.receive_newsletter returns "no":
  #   radio_button("receive_newsletter", "yes")
  #   radio_button("receive_newsletter", "no")
  #   # => <input type="radio" id="user_receive_newsletter_yes" name="user[receive_newsletter]" value="yes" />
  #   #    <input type="radio" id="user_receive_newsletter_no" name="user[receive_newsletter]" value="no" checked="checked" />
  def radio_button(method, tag_value, options = T.unsafe(nil)); end

  def range_field(method, options = T.unsafe(nil)); end
  def rich_text_area(method, options = T.unsafe(nil)); end
  def search_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::FormOptionsHelper#select for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.select :person_id, Person.all.collect { |p| [ p.name, p.id ] }, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def select(method, choices = T.unsafe(nil), options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Add the submit button for the given form. When no value is given, it checks
  # if the object is a new resource or not to create the proper label:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # In the example above, if <tt>@post</tt> is a new record, it will use "Create Post" as
  # submit button label; otherwise, it uses "Update Post".
  #
  # Those labels can be customized using I18n under the +helpers.submit+ key and using
  # <tt>%{model}</tt> for translation interpolation:
  #
  #   en:
  #     helpers:
  #       submit:
  #         create: "Create a %{model}"
  #         update: "Confirm changes to %{model}"
  #
  # It also searches for a key specific to the given object:
  #
  #   en:
  #     helpers:
  #       submit:
  #         post:
  #           create: "Add %{model}"
  def submit(value = T.unsafe(nil), options = T.unsafe(nil)); end

  def telephone_field(method, options = T.unsafe(nil)); end
  def text_area(method, options = T.unsafe(nil)); end
  def text_field(method, options = T.unsafe(nil)); end
  def time_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::DateHelper#time_select for form builders:
  #
  #   <%= form_for @race do |f| %>
  #     <%= f.time_select :average_lap %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def time_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::FormOptionsHelper#time_zone_select for form builders:
  #
  #   <%= form_for @user do |f| %>
  #     <%= f.time_zone_select :time_zone, nil, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def time_zone_select(method, priority_zones = T.unsafe(nil), options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  def to_model; end
  def to_partial_path; end
  def url_field(method, options = T.unsafe(nil)); end
  def week_field(method, options = T.unsafe(nil)); end

  # Wraps ActionView::Helpers::FormOptionsHelper#weekday_select for form builders:
  #
  #   <%= form_for @user do |f| %>
  #     <%= f.weekday_select :weekday, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def weekday_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  private

  def convert_to_legacy_options(options); end
  def fields_for_nested_model(name, object, fields_options, block); end
  def fields_for_with_nested_attributes(association_name, association, options, block); end

  # @return [Boolean]
  def nested_attributes_association?(association_name); end

  def nested_child_index(name); end
  def objectify_options(options); end
  def submit_default_value; end

  class << self
    def _to_partial_path; end
    def field_helpers; end
    def field_helpers=(value); end
    def field_helpers?; end
  end
end

module SimpleForm
  extend ::ActiveSupport::Autoload

  def boolean_label_class; end
  def boolean_label_class=(val); end
  def boolean_style; end
  def boolean_style=(val); end
  def browser_validations; end
  def browser_validations=(val); end
  def button_class; end
  def button_class=(val); end
  def cache_discovery; end
  def cache_discovery=(val); end
  def collection_label_methods; end
  def collection_label_methods=(val); end
  def collection_value_methods; end
  def collection_value_methods=(val); end
  def collection_wrapper_class; end
  def collection_wrapper_class=(val); end
  def collection_wrapper_tag; end
  def collection_wrapper_tag=(val); end
  def country_priority; end
  def country_priority=(val); end
  def custom_inputs_namespaces; end
  def custom_inputs_namespaces=(val); end
  def default_form_class; end
  def default_form_class=(val); end

  # WRAPPER CONFIGURATION
  # The default wrapper to be used by the FormBuilder.
  def default_wrapper; end

  def default_wrapper=(val); end
  def error_method; end
  def error_method=(val); end
  def error_notification_class; end
  def error_notification_class=(val); end
  def error_notification_tag; end
  def error_notification_tag=(val); end
  def field_error_proc; end
  def field_error_proc=(val); end
  def form_class; end
  def generate_additional_classes_for; end
  def generate_additional_classes_for=(val); end
  def i18n_scope; end
  def i18n_scope=(val); end
  def include_default_input_wrapper_class; end
  def include_default_input_wrapper_class=(val); end
  def input_class; end
  def input_class=(val); end
  def input_field_error_class; end
  def input_field_error_class=(val); end
  def input_field_valid_class; end
  def input_field_valid_class=(val); end
  def input_mappings; end
  def input_mappings=(val); end
  def inputs_discovery; end
  def inputs_discovery=(val); end
  def item_wrapper_class; end
  def item_wrapper_class=(val); end
  def item_wrapper_tag; end
  def item_wrapper_tag=(val); end
  def label_class; end
  def label_class=(val); end
  def label_text; end
  def label_text=(val); end
  def required_by_default; end
  def required_by_default=(val); end
  def time_zone_priority; end
  def time_zone_priority=(val); end
  def translate_labels; end
  def translate_labels=(val); end
  def wrapper_mappings; end
  def wrapper_mappings=(val); end

  class << self
    def additional_classes_for(component); end
    def boolean_label_class; end
    def boolean_label_class=(val); end
    def boolean_style; end
    def boolean_style=(val); end
    def browser_validations; end
    def browser_validations=(val); end

    # Builds a new wrapper using SimpleForm::Wrappers::Builder.
    #
    # @yield [builder]
    def build(options = T.unsafe(nil)); end

    def button_class; end
    def button_class=(val); end
    def cache_discovery; end
    def cache_discovery=(val); end
    def collection_label_methods; end
    def collection_label_methods=(val); end
    def collection_value_methods; end
    def collection_value_methods=(val); end
    def collection_wrapper_class; end
    def collection_wrapper_class=(val); end
    def collection_wrapper_tag; end
    def collection_wrapper_tag=(val); end

    # @return [Boolean]
    def configured?; end

    def country_priority; end
    def country_priority=(val); end
    def custom_inputs_namespaces; end
    def custom_inputs_namespaces=(val); end
    def default_form_class; end
    def default_form_class=(val); end

    # SETUP
    def default_input_size=(*_arg0); end

    def default_wrapper; end
    def default_wrapper=(val); end
    def eager_load!; end
    def error_method; end
    def error_method=(val); end
    def error_notification_class; end
    def error_notification_class=(val); end
    def error_notification_tag; end
    def error_notification_tag=(val); end
    def field_error_proc; end
    def field_error_proc=(val); end
    def file_methods; end
    def file_methods=(file_methods); end
    def form_class; end
    def form_class=(value); end
    def generate_additional_classes_for; end
    def generate_additional_classes_for=(val); end
    def i18n_scope; end
    def i18n_scope=(val); end

    # Includes a component to be used by Simple Form. Methods defined in a
    # component will be exposed to be used in the wrapper as Simple::Components
    #
    # Examples
    #
    #    # The application needs to tell where the components will be.
    #    Dir[Rails.root.join('lib/components/**/*.rb')].each { |f| require f }
    #
    #    # Create a custom component in the path specified above.
    #    # lib/components/input_group_component.rb
    #    module InputGroupComponent
    #      def prepend
    #        ...
    #      end
    #
    #      def append
    #        ...
    #      end
    #    end
    #
    #    SimpleForm.setup do |config|
    #      # Create a wrapper using the custom component.
    #      config.wrappers :input_group, tag: :div, error_class: :error do |b|
    #        b.use :label
    #        b.optional :prepend
    #        b.use :input
    #        b.use :append
    #      end
    #    end
    #
    #    # Using the custom component in the form.
    #    <%= simple_form_for @blog, wrapper: input_group do |f| %>
    #      <%= f.input :title, prepend: true %>
    #    <% end %>
    def include_component(component); end

    def include_default_input_wrapper_class; end
    def include_default_input_wrapper_class=(val); end
    def input_class; end
    def input_class=(val); end
    def input_field_error_class; end
    def input_field_error_class=(val); end
    def input_field_valid_class; end
    def input_field_valid_class=(val); end
    def input_mappings; end
    def input_mappings=(val); end
    def inputs_discovery; end
    def inputs_discovery=(val); end
    def item_wrapper_class; end
    def item_wrapper_class=(val); end
    def item_wrapper_tag; end
    def item_wrapper_tag=(val); end
    def label_class; end
    def label_class=(val); end
    def label_text; end
    def label_text=(val); end
    def required_by_default; end
    def required_by_default=(val); end

    # Default way to setup Simple Form. Run rails generate simple_form:install
    # to create a fresh initializer with all configuration values.
    #
    # @yield [_self]
    # @yieldparam _self [SimpleForm] the object that the method was called on
    def setup; end

    def time_zone_priority; end
    def time_zone_priority=(val); end
    def translate_labels; end
    def translate_labels=(val); end

    # Retrieves a given wrapper
    def wrapper(name); end

    def wrapper_mappings; end
    def wrapper_mappings=(val); end

    # Define a new wrapper using SimpleForm::Wrappers::Builder
    # and store it in the given name.
    def wrappers(*args, &block); end
  end
end

module SimpleForm::ActionViewExtensions; end

# A collection of methods required by simple_form but added to rails default form.
# This means that you can use such methods outside simple_form context.
module SimpleForm::ActionViewExtensions::Builder
  # Wrapper for using SimpleForm inside a default rails form.
  # Example:
  #
  #   form_for @user do |f|
  #     f.simple_fields_for :posts do |posts_form|
  #       # Here you have all simple_form methods available
  #       posts_form.input :title
  #     end
  #   end
  def simple_fields_for(*args, &block); end
end

# This module creates SimpleForm wrappers around default form_for and fields_for.
#
# Example:
#
#   simple_form_for @user do |f|
#     f.input :name, hint: 'My hint'
#   end
module SimpleForm::ActionViewExtensions::FormHelper
  def simple_fields_for(record_name, record_object = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def simple_form_for(record, options = T.unsafe(nil), &block); end

  private

  def simple_form_css_class(record, options); end
  def with_simple_form_field_error_proc; end
end

SimpleForm::CUSTOM_INPUT_DEPRECATION_WARN = T.let(T.unsafe(nil), String)

# Components are a special type of helpers that can work on their own.
# For example, by using a component, it will automatically change the
# output under given circumstances without user input. For example,
# the disabled helper always need a disabled: true option given
# to the input in order to be enabled. On the other hand, things like
# hints can generate output automatically by doing I18n lookups.
module SimpleForm::Components
  extend ::ActiveSupport::Autoload
end

module SimpleForm::Components::Errors
  def error(wrapper_options = T.unsafe(nil)); end
  def full_error(wrapper_options = T.unsafe(nil)); end

  # @return [Boolean]
  def has_errors?; end

  # @return [Boolean]
  def has_value?; end

  # @return [Boolean]
  def valid?; end

  protected

  def error_method; end
  def error_text; end
  def errors; end
  def errors_on_association; end
  def errors_on_attribute; end
  def full_error_text; end
  def full_errors; end
  def full_errors_on_association; end
  def full_errors_on_attribute; end

  # @return [Boolean]
  def has_custom_error?; end

  # @return [Boolean]
  def object_with_errors?; end
end

module SimpleForm::Components::HTML5
  def initialize(*_arg0); end

  # @return [Boolean]
  def has_required?; end

  def html5(wrapper_options = T.unsafe(nil)); end

  # @return [Boolean]
  def html5?; end

  def input_html_aria_required_option; end
  def input_html_required_option; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Hints
  # @return [Boolean]
  def has_hint?; end

  def hint(wrapper_options = T.unsafe(nil)); end
end

module SimpleForm::Components::LabelInput
  extend ::ActiveSupport::Concern
  include ::SimpleForm::Components::Labels

  mixes_in_class_methods ::SimpleForm::Components::Labels::ClassMethods

  def label_input(wrapper_options = T.unsafe(nil)); end

  private

  def deprecated_component(namespace, wrapper_options); end
end

module SimpleForm::Components::Labels
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SimpleForm::Components::Labels::ClassMethods

  def label(wrapper_options = T.unsafe(nil)); end
  def label_html_options; end
  def label_target; end
  def label_text(wrapper_options = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  def generate_label_for_attribute?; end

  # First check labels translation and then human attribute name.
  def label_translation; end

  def raw_label_text; end

  # Default required text when attribute is required.
  def required_label_text; end
end

module SimpleForm::Components::Labels::ClassMethods
  def translate_required_html; end
  def translate_required_mark; end
  def translate_required_text; end

  private

  def i18n_scope; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Maxlength
  def maxlength(wrapper_options = T.unsafe(nil)); end

  private

  def find_length_validator; end
  def maximum_length_from_validation; end
  def maximum_length_value_from(length_validator); end
end

module SimpleForm::Components::MinMax
  def min_max(wrapper_options = T.unsafe(nil)); end

  private

  def evaluate_numericality_validator_option(option); end
  def find_numericality_validator; end

  # @return [Boolean]
  def integer?; end

  def maximum_value(validator_options); end
  def minimum_value(validator_options); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Minlength
  def minlength(wrapper_options = T.unsafe(nil)); end

  private

  def find_length_validator; end
  def minimum_length_from_validation; end
  def minimum_length_value_from(length_validator); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Pattern
  def pattern(wrapper_options = T.unsafe(nil)); end

  private

  def evaluate_format_validator_option(option); end
  def find_pattern_validator; end
  def pattern_source; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Placeholders
  def placeholder(wrapper_options = T.unsafe(nil)); end
  def placeholder_text(wrapper_options = T.unsafe(nil)); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Readonly
  def readonly(wrapper_options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def readonly_attribute?; end
end

class SimpleForm::ErrorNotification
  # @return [ErrorNotification] a new instance of ErrorNotification
  def initialize(builder, options); end

  def object(*_arg0, **_arg1, &_arg2); end
  def object_name(*_arg0, **_arg1, &_arg2); end
  def render; end
  def template(*_arg0, **_arg1, &_arg2); end

  protected

  def error_message; end
  def error_notification_tag; end
  def errors; end

  # @return [Boolean]
  def has_errors?; end

  def html_options; end
  def translate_error_notification; end
end

SimpleForm::FILE_METHODS_DEPRECATION_WARN = T.let(T.unsafe(nil), String)

class SimpleForm::FormBuilder < ::ActionView::Helpers::FormBuilder
  include ::SimpleForm::Inputs
  extend ::SimpleForm::MapType

  # @return [FormBuilder] a new instance of FormBuilder
  def initialize(*_arg0); end

  # Helper for dealing with association selects/radios, generating the
  # collection automatically. It's just a wrapper to input, so all options
  # supported in input are also supported by association. Some extra options
  # can also be given:
  #
  # == Examples
  #
  #   simple_form_for @user do |f|
  #     f.association :company          # Company.all
  #   end
  #
  #   f.association :company, collection: Company.all(order: 'name')
  #   # Same as using :order option, but overriding collection
  #
  # == Block
  #
  # When a block is given, association simple behaves as a proxy to
  # simple_fields_for:
  #
  #   f.association :company do |c|
  #     c.input :name
  #     c.input :type
  #   end
  #
  # From the options above, only :collection can also be supplied.
  #
  # Please note that the association helper is currently only tested with Active Record. Depending on the ORM you are using your mileage may vary.
  #
  # @raise [ArgumentError]
  def association(association, options = T.unsafe(nil), &block); end

  # Basic input helper, combines all components in the stack to generate
  # input html based on options the user define and some guesses through
  # database column information. By default a call to input will generate
  # label + input + hint (when defined) + errors (when exists), and all can
  # be configured inside a wrapper html.
  #
  # If a block is given, the contents of the block will replace the input
  # field that would otherwise be generated automatically. The content will
  # be given a label and wrapper div to make it consistent with the other
  # elements in the form.
  #
  # == Examples
  #
  #   # Imagine @user has error "can't be blank" on name
  #   simple_form_for @user do |f|
  #     f.input :name, hint: 'My hint'
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <label class="string required" for="user_name">
  #       <abbr title="required">*</abbr> Super User Name!
  #     </label>
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #     <span class="hint">My hint</span>
  #     <span class="error">can't be blank</span>
  #
  # Each database type will render a default input, based on some mappings and
  # heuristic to determine which is the best option.
  #
  # You have some options for the input to enable/disable some functions:
  #
  #   as: allows you to define the input type you want, for instance you
  #          can use it to generate a text field for a date column.
  #
  #   required: defines whether this attribute is required or not. True
  #               by default.
  #
  # The fact SimpleForm is built in components allow the interface to be unified.
  # So, for instance, if you need to disable :hint for a given input, you can pass
  # hint: false. The same works for :error, :label and :wrapper.
  #
  # Besides the html for any component can be changed. So, if you want to change
  # the label html you just need to give a hash to :label_html. To configure the
  # input html, supply :input_html instead and so on.
  #
  # == Options
  #
  # Some inputs, as datetime, time and select allow you to give extra options, like
  # prompt and/or include blank. Such options are given in plainly:
  #
  #    f.input :created_at, include_blank: true
  #
  # == Collection
  #
  # When playing with collections (:radio_buttons, :check_boxes and :select
  # inputs), you have three extra options:
  #
  #   collection: use to determine the collection to generate the radio or select
  #
  #   label_method: the method to apply on the array collection to get the label
  #
  #   value_method: the method to apply on the array collection to get the value
  #
  # == Priority
  #
  # Some inputs, as :time_zone and :country accepts a :priority option. If none is
  # given SimpleForm.time_zone_priority and SimpleForm.country_priority are used respectively.
  def attribute(attribute_name, options = T.unsafe(nil), &block); end

  def button(type, *args, &block); end

  # Creates a button:
  #
  #   form_for @user do |f|
  #     f.button :submit
  #   end
  #
  # It just acts as a proxy to method name given. We also alias original Rails
  # button implementation (3.2 forward (to delegate to the original when
  # calling `f.button :button`.
  def button_button(value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Creates a collection of check boxes for each item in the collection,
  # associated with a clickable label. Use value_method and text_method to
  # convert items in the collection for use as text/value in check boxes.
  # You can give a symbol or a proc to both value_method and text_method,
  # that will be evaluated for each item in the collection.
  #
  # == Examples
  #
  #   form_for @user do |f|
  #     f.collection_check_boxes :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #   end
  #
  #   <input name="user[options][]" type="hidden" value="" />
  #   <input id="user_options_true" name="user[options][]" type="checkbox" value="true" />
  #   <label class="collection_check_boxes" for="user_options_true">Yes</label>
  #   <input name="user[options][]" type="hidden" value="" />
  #   <input id="user_options_false" name="user[options][]" type="checkbox" value="false" />
  #   <label class="collection_check_boxes" for="user_options_false">No</label>
  #
  # It is also possible to give a block that should generate the check box +
  # label. To wrap the check box with the label, for instance:
  #
  #   form_for @user do |f|
  #     f.collection_check_boxes(
  #       :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #     ) do |b|
  #       b.label { b.check_box + b.text }
  #     end
  #   end
  #
  # == Options
  #
  # Collection check box accepts some extra options:
  #
  #   * checked  => the value or values that should be checked initially. Accepts
  #                 a single item or an array of items. It overrides existing associations.
  #
  #   * disabled => the value or values that should be disabled. Accepts a single
  #                 item or an array of items.
  #
  #   * collection_wrapper_tag   => the tag to wrap the entire collection.
  #
  #   * collection_wrapper_class => the CSS class to use for collection_wrapper_tag. This option
  #                                 is ignored if the :collection_wrapper_tag option is blank.
  #
  #   * item_wrapper_tag         => the tag to wrap each item in the collection.
  #
  #   * item_wrapper_class       => the CSS class to use for item_wrapper_tag
  #
  #   * a block                  => to generate the label + check box or any other component.
  def collection_check_boxes(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Create a collection of radio inputs for the attribute. Basically this
  # helper will create a radio input associated with a label for each
  # text/value option in the collection, using value_method and text_method
  # to convert these text/value. You can give a symbol or a proc to both
  # value_method and text_method, that will be evaluated for each item in
  # the collection.
  #
  # == Examples
  #
  #   form_for @user do |f|
  #     f.collection_radio_buttons :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #   end
  #
  #   <input id="user_options_true" name="user[options]" type="radio" value="true" />
  #   <label class="collection_radio_buttons" for="user_options_true">Yes</label>
  #   <input id="user_options_false" name="user[options]" type="radio" value="false" />
  #   <label class="collection_radio_buttons" for="user_options_false">No</label>
  #
  # It is also possible to give a block that should generate the radio +
  # label. To wrap the radio with the label, for instance:
  #
  #   form_for @user do |f|
  #     f.collection_radio_buttons(
  #       :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #     ) do |b|
  #       b.label { b.radio_button + b.text }
  #     end
  #   end
  #
  # == Options
  #
  # Collection radio accepts some extra options:
  #
  #   * checked  => the value that should be checked initially.
  #
  #   * disabled => the value or values that should be disabled. Accepts a single
  #                 item or an array of items.
  #
  #   * collection_wrapper_tag   => the tag to wrap the entire collection.
  #
  #   * collection_wrapper_class => the CSS class to use for collection_wrapper_tag
  #
  #   * item_wrapper_tag         => the tag to wrap each item in the collection.
  #
  #   * item_wrapper_class       => the CSS class to use for item_wrapper_tag
  #
  #   * a block                  => to generate the label + radio or any other component.
  def collection_radio_buttons(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Creates an error tag based on the given attribute, only when the attribute
  # contains errors. All the given options are sent as :error_html.
  #
  # == Examples
  #
  #    f.error :name
  #    f.error :name, id: "cool_error"
  def error(attribute_name, options = T.unsafe(nil)); end

  # Creates an error notification message that only appears when the form object
  # has some error. You can give a specific message with the :message option,
  # otherwise it will look for a message using I18n. All other options given are
  # passed straight as html options to the html tag.
  #
  # == Examples
  #
  #    f.error_notification
  #    f.error_notification message: 'Something went wrong'
  #    f.error_notification id: 'user_error_message', class: 'form_error'
  def error_notification(options = T.unsafe(nil)); end

  # Return the error but also considering its name. This is used
  # when errors for a hidden field need to be shown.
  #
  # == Examples
  #
  #    f.full_error :token #=> <span class="error">Token is invalid</span>
  def full_error(attribute_name, options = T.unsafe(nil)); end

  # Creates a hint tag for the given attribute. Accepts a symbol indicating
  # an attribute for I18n lookup or a string. All the given options are sent
  # as :hint_html.
  #
  # == Examples
  #
  #    f.hint :name # Do I18n lookup
  #    f.hint :name, id: "cool_hint"
  #    f.hint "Don't forget to accept this"
  def hint(attribute_name, options = T.unsafe(nil)); end

  # Basic input helper, combines all components in the stack to generate
  # input html based on options the user define and some guesses through
  # database column information. By default a call to input will generate
  # label + input + hint (when defined) + errors (when exists), and all can
  # be configured inside a wrapper html.
  #
  # If a block is given, the contents of the block will replace the input
  # field that would otherwise be generated automatically. The content will
  # be given a label and wrapper div to make it consistent with the other
  # elements in the form.
  #
  # == Examples
  #
  #   # Imagine @user has error "can't be blank" on name
  #   simple_form_for @user do |f|
  #     f.input :name, hint: 'My hint'
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <label class="string required" for="user_name">
  #       <abbr title="required">*</abbr> Super User Name!
  #     </label>
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #     <span class="hint">My hint</span>
  #     <span class="error">can't be blank</span>
  #
  # Each database type will render a default input, based on some mappings and
  # heuristic to determine which is the best option.
  #
  # You have some options for the input to enable/disable some functions:
  #
  #   as: allows you to define the input type you want, for instance you
  #          can use it to generate a text field for a date column.
  #
  #   required: defines whether this attribute is required or not. True
  #               by default.
  #
  # The fact SimpleForm is built in components allow the interface to be unified.
  # So, for instance, if you need to disable :hint for a given input, you can pass
  # hint: false. The same works for :error, :label and :wrapper.
  #
  # Besides the html for any component can be changed. So, if you want to change
  # the label html you just need to give a hash to :label_html. To configure the
  # input html, supply :input_html instead and so on.
  #
  # == Options
  #
  # Some inputs, as datetime, time and select allow you to give extra options, like
  # prompt and/or include blank. Such options are given in plainly:
  #
  #    f.input :created_at, include_blank: true
  #
  # == Collection
  #
  # When playing with collections (:radio_buttons, :check_boxes and :select
  # inputs), you have three extra options:
  #
  #   collection: use to determine the collection to generate the radio or select
  #
  #   label_method: the method to apply on the array collection to get the label
  #
  #   value_method: the method to apply on the array collection to get the value
  #
  # == Priority
  #
  # Some inputs, as :time_zone and :country accepts a :priority option. If none is
  # given SimpleForm.time_zone_priority and SimpleForm.country_priority are used respectively.
  def input(attribute_name, options = T.unsafe(nil), &block); end

  # Creates a input tag for the given attribute. All the given options
  # are sent as :input_html.
  #
  # == Examples
  #
  #   simple_form_for @user do |f|
  #     f.input_field :name
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #
  # It also support validation classes once it is configured.
  #
  #   # config/initializers/simple_form.rb
  #   SimpleForm.setup do |config|
  #     config.input_field_valid_class = 'is-valid'
  #     config.input_field_error_class = 'is-invalid'
  #   end
  #
  #   simple_form_for @user do |f|
  #     f.input_field :name
  #   end
  #
  # When the validation happens, the input will be rendered with
  # the class configured according to the validation:
  #
  # - when the input is valid:
  #
  #     <input class="is-valid string required" id="user_name" value="Carlos" />
  #
  # - when the input is invalid:
  #
  #     <input class="is-invalid string required" id="user_name" value="" />
  def input_field(attribute_name, options = T.unsafe(nil)); end

  # Creates a default label tag for the given attribute. You can give a label
  # through the :label option or using i18n. All the given options are sent
  # as :label_html.
  #
  # == Examples
  #
  #    f.label :name                     # Do I18n lookup
  #    f.label :name, "Name"             # Same behavior as Rails, do not add required tag
  #    f.label :name, label: "Name"      # Same as above, but adds required tag
  #
  #    f.label :name, required: false
  #    f.label :name, id: "cool_label"
  def label(attribute_name, *args); end

  # The action to be used in lookup.
  def lookup_action; end

  # Extract the model names from the object_name mess, ignoring numeric and
  # explicit child indexes.
  #
  # Example:
  #
  # route[blocks_attributes][0][blocks_learning_object_attributes][1][foo_attributes]
  # ["route", "blocks", "blocks_learning_object", "foo"]
  def lookup_model_names; end

  def mappings; end
  def mappings=(_arg0); end
  def mappings?; end

  # Returns the value of attribute object.
  def object; end

  # Returns the value of attribute object_name.
  def object_name; end

  # Returns the value of attribute template.
  def template; end

  # Returns the value of attribute wrapper.
  def wrapper; end

  private

  def attempt_mapping(mapping, at); end
  def attempt_mapping_with_custom_namespace(input_name); end
  def build_association_attribute(reflection, association, options); end
  def build_input_field_components(components); end
  def build_input_field_options; end

  # Attempt to guess the better input type given the defined options. By
  # default always fallback to the user :as option, or to a :select when a
  # collection is given.
  def default_input_type(attribute_name, column, options); end

  # If cache_discovery is enabled, use the class level cache that persists
  # between requests, otherwise use the instance one.
  def discovery_cache; end

  def fetch_association_collection(reflection, options); end

  # Internal: Try to discover whether an attribute corresponds to a file or not.
  #
  # Most upload Gems add some kind of attributes to the ActiveRecord's model they are included in.
  # This method tries to guess if an attribute belongs to some of these Gems by checking the presence
  # of their methods using `#respond_to?`.
  #
  # Note: This does not support multiple file upload inputs, as this is very application-specific.
  #
  # The order here was chosen based on the popularity of Gems:
  #
  # - `#{attribute_name}_attachment` - ActiveStorage >= `5.2` and Refile >= `0.2.0` <= `0.4.0`
  # - `remote_#{attribute_name}_url` - Refile >= `0.3.0` and CarrierWave >= `0.2.2`
  # - `#{attribute_name}_attacher` - Refile >= `0.4.0` and Shrine >= `0.9.0`
  # - `#{attribute_name}_file_name` - Paperclip ~> `2.0` (added for backwards compatibility)
  #
  # Returns a Boolean.
  #
  # @return [Boolean]
  def file_method?(attribute_name); end

  def find_association_reflection(association); end
  def find_attribute_column(attribute_name); end
  def find_custom_type(attribute_name); end

  # Find an input based on the attribute name.
  def find_input(attribute_name, options = T.unsafe(nil), &block); end

  # Attempts to find a mapping. It follows the following rules:
  #
  # 1) It tries to find a registered mapping, if succeeds:
  #    a) Try to find an alternative with the same name in the Object scope
  #    b) Or use the found mapping
  # 2) If not, fallbacks to #{input_type}Input
  # 3) If not, fallbacks to SimpleForm::Inputs::#{input_type}Input
  def find_mapping(input_type); end

  def find_wrapper(input_type, options); end

  # Attempts to find a wrapper mapping. It follows the following rules:
  #
  # 1) It tries to find a wrapper for the current form
  # 2) If not, it tries to find a config
  def find_wrapper_mapping(input_type); end

  def mapping_override(klass); end

  class << self
    def discovery_cache; end
    def mappings; end
    def mappings=(value); end
    def mappings?; end
  end
end

# When action is create or update, we still should use new and edit
SimpleForm::FormBuilder::ACTIONS = T.let(T.unsafe(nil), Hash)

SimpleForm::FormBuilder::ATTRIBUTE_COMPONENTS = T.let(T.unsafe(nil), Array)

# Helpers are made of several helpers that cannot be turned on automatically.
# For instance, disabled cannot be turned on automatically, it requires the
# user to explicitly pass the option disabled: true so it may work.
module SimpleForm::Helpers; end

module SimpleForm::Helpers::Autofocus
  private

  # @return [Boolean]
  def has_autofocus?; end
end

module SimpleForm::Helpers::Disabled
  private

  def disabled_class; end

  # @return [Boolean]
  def has_disabled?; end
end

module SimpleForm::Helpers::Readonly
  private

  # @return [Boolean]
  def has_readonly?; end

  def readonly_class; end
end

module SimpleForm::Helpers::Required
  private

  def calculate_required; end

  # @return [Boolean]
  def required_by_default?; end

  # @return [Boolean]
  def required_by_validators?; end

  # Do not use has_required? because we want to add the class
  # regardless of the required option.
  def required_class; end

  # @return [Boolean]
  def required_field?; end
end

module SimpleForm::Helpers::Validators
  # @return [Boolean]
  def has_validators?; end

  private

  # @return [Boolean]
  def action_validator_match?(validator); end

  def attribute_validators; end

  # @return [Boolean]
  def conditional_validators?(validator); end

  def find_validator(kind); end
  def reflection_validators; end

  # @return [Boolean]
  def valid_validator?(validator); end
end

module SimpleForm::Inputs
  extend ::ActiveSupport::Autoload
end

class SimpleForm::Inputs::Base
  include ::ERB::Util
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::SimpleForm::Helpers::Autofocus
  include ::SimpleForm::Helpers::Disabled
  include ::SimpleForm::Helpers::Readonly
  include ::SimpleForm::Helpers::Required
  include ::SimpleForm::Helpers::Validators
  include ::SimpleForm::Components::Errors
  include ::SimpleForm::Components::Hints
  include ::SimpleForm::Components::HTML5
  include ::SimpleForm::Components::LabelInput
  include ::SimpleForm::Components::Labels
  include ::SimpleForm::Components::Maxlength
  include ::SimpleForm::Components::Minlength
  include ::SimpleForm::Components::MinMax
  include ::SimpleForm::Components::Pattern
  include ::SimpleForm::Components::Placeholders
  include ::SimpleForm::Components::Readonly
  extend ::SimpleForm::Components::Labels::ClassMethods

  # @return [Base] a new instance of Base
  def initialize(builder, attribute_name, column, input_type, options = T.unsafe(nil)); end

  def additional_classes; end

  # Returns the value of attribute attribute_name.
  def attribute_name; end

  # Returns the value of attribute column.
  def column; end

  def debug_missing_translation; end
  def debug_missing_translation=(val); end
  def default_options; end
  def default_options=(_arg0); end
  def default_options?; end

  # Returns the value of attribute html_classes.
  def html_classes; end

  # @raise [NotImplementedError]
  def input(wrapper_options = T.unsafe(nil)); end

  def input_class; end

  # Returns the value of attribute input_html_classes.
  def input_html_classes; end

  # Returns the value of attribute input_html_options.
  def input_html_options; end

  def input_options; end

  # Returns the value of attribute input_type.
  def input_type; end

  def lookup_action(*_arg0, **_arg1, &_arg2); end
  def lookup_model_names(*_arg0, **_arg1, &_arg2); end
  def object(*_arg0, **_arg1, &_arg2); end
  def object_name(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute reflection.
  def reflection; end

  def template(*_arg0, **_arg1, &_arg2); end

  private

  def column_limit; end

  # Add one for decimal point
  def decimal_limit; end

  # @return [Boolean]
  def decimal_or_float?; end

  # Retrieve options for the given namespace from the options hash
  def html_options_for(namespace, css_classes); end

  def i18n_scope; end
  def limit; end
  def merge_wrapper_options(options, wrapper_options); end

  # @return [Boolean]
  def nested_boolean_style?; end

  # Find reflection name when available, otherwise use attribute
  def reflection_or_attribute_name; end

  def set_input_classes(wrapper_options); end

  # Lookup translations for the given namespace using I18n, based on object name,
  # actual action and attribute name. Lookup priority as follows:
  #
  #   simple_form.{namespace}.{model}.{action}.{attribute}
  #   simple_form.{namespace}.{model}.{attribute}
  #   simple_form.{namespace}.defaults.{attribute}
  #
  #  Namespace is used for :labels and :hints.
  #
  #  Model is the actual object name, for a @user object you'll have :user.
  #  Action is the action being rendered, usually :new or :edit.
  #  And attribute is the attribute itself, :name for example.
  #
  #  The lookup for nested attributes is also done in a nested format using
  #  both model and nested object names, such as follow:
  #
  #   simple_form.{namespace}.{model}.{nested}.{action}.{attribute}
  #   simple_form.{namespace}.{model}.{nested}.{attribute}
  #   simple_form.{namespace}.{nested}.{action}.{attribute}
  #   simple_form.{namespace}.{nested}.{attribute}
  #   simple_form.{namespace}.defaults.{attribute}
  #
  #  Example:
  #
  #    simple_form:
  #      labels:
  #        user:
  #          new:
  #            email: 'E-mail para efetuar o sign in.'
  #          edit:
  #            email: 'E-mail.'
  #
  #  Take a look at our locale example file.
  def translate_from_namespace(namespace, default = T.unsafe(nil)); end

  class << self
    def debug_missing_translation; end
    def debug_missing_translation=(val); end
    def default_options; end
    def default_options=(value); end
    def default_options?; end
    def disable(*keys); end
    def enable(*keys); end
  end
end

class SimpleForm::Inputs::BlockInput < ::SimpleForm::Inputs::Base
  # @return [BlockInput] a new instance of BlockInput
  def initialize(*args, &block); end

  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::BooleanInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
  def label_input(wrapper_options = T.unsafe(nil)); end

  private

  def boolean_label_class; end

  # Build a checkbox tag using default unchecked value. This allows us to
  # reuse the method for nested boolean style, but with no unchecked value,
  # which won't generate the hidden checkbox. This is the default functionality
  # in Rails > 3.2.1, and is backported in SimpleForm AV helpers.
  def build_check_box(unchecked_value, options); end

  # Build a checkbox without generating the hidden field. See
  # #build_hidden_field_for_checkbox for more info.
  def build_check_box_without_hidden_field(options); end

  # Create a hidden field for the current checkbox, so we can simulate Rails
  # functionality with hidden + checkbox, but under a nested context, where
  # we need the hidden field to be *outside* the label (otherwise it
  # generates invalid html - html5 only).
  def build_hidden_field_for_checkbox; end

  def checked_value; end

  # @return [Boolean]
  def include_hidden?; end

  def inline_label; end

  # @return [Boolean]
  def inline_label?; end

  # Booleans are not required by default because in most of the cases
  # it makes no sense marking them as required. The only exception is
  # Terms of Use usually presented at most sites sign up screen.
  #
  # @return [Boolean]
  def required_by_default?; end

  def unchecked_value; end
end

class SimpleForm::Inputs::CollectionCheckBoxesInput < ::SimpleForm::Inputs::CollectionRadioButtonsInput
  protected

  def build_nested_boolean_style_item_tag(collection_builder); end

  # Checkbox components do not use the required html tag.
  # More info: https://github.com/heartcombo/simple_form/issues/340#issuecomment-2871956
  #
  # @return [Boolean]
  def has_required?; end

  def item_wrapper_class; end
end

class SimpleForm::Inputs::CollectionInput < ::SimpleForm::Inputs::Base
  # @raise [NotImplementedError]
  def input(wrapper_options = T.unsafe(nil)); end

  def input_options; end

  private

  def collection; end

  # @return [Boolean]
  def collection_includes_basic_objects?(collection_classes); end

  def detect_collection_classes(some_collection = T.unsafe(nil)); end

  # Detect the right method to find the label and value for a collection.
  # If no label or value method are defined, will attempt to find them based
  # on default label and value methods that can be configured through
  # SimpleForm.collection_label_methods and
  # SimpleForm.collection_value_methods.
  def detect_collection_methods; end

  def detect_common_display_methods(collection_classes = T.unsafe(nil)); end
  def detect_method_from_class(collection_classes); end

  # @return [Boolean]
  def has_required?; end

  # @return [Boolean]
  def multiple?; end

  # Check if :include_blank must be included by default.
  #
  # @return [Boolean]
  def skip_include_blank?; end

  def translate_collection; end
  def translate_option(options, key); end

  class << self
    # Default boolean collection for use with selects/radios when no
    # collection is given. Always fallback to this boolean collection.
    # Texts can be translated using i18n in "simple_form.yes" and
    # "simple_form.no" keys. See the example locale file.
    def boolean_collection; end
  end
end

SimpleForm::Inputs::CollectionInput::BASIC_OBJECT_CLASSES = T.let(T.unsafe(nil), Array)

class SimpleForm::Inputs::CollectionRadioButtonsInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end
  def input_options; end

  protected

  def apply_default_collection_options!(options); end
  def build_nested_boolean_style_item_tag(collection_builder); end
  def collection_block_for_nested_boolean_style; end

  # Do not attempt to generate label[for] attributes by default, unless an
  # explicit html option is given. This avoids generating labels pointing to
  # non existent fields.
  #
  # @return [Boolean]
  def generate_label_for_attribute?; end

  def item_wrapper_class; end
end

class SimpleForm::Inputs::CollectionSelectInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::ColorInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::DateTimeInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  def label_target; end

  # @return [Boolean]
  def use_html5_inputs?; end
end

class SimpleForm::Inputs::FileInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::GroupedCollectionSelectInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end

  private

  # Sample collection
  def collection; end

  def detect_method_from_class(collection_classes); end
  def group_label_method; end
  def group_method; end
  def grouped_collection; end
end

class SimpleForm::Inputs::HiddenInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  def required_class; end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::NumericInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::PasswordInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::PriorityInput < ::SimpleForm::Inputs::CollectionSelectInput
  def input(wrapper_options = T.unsafe(nil)); end
  def input_priority; end

  protected

  # @return [Boolean]
  def skip_include_blank?; end
end

class SimpleForm::Inputs::RangeInput < ::SimpleForm::Inputs::NumericInput
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::RichTextAreaInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::StringInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def string?; end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::TextInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

module SimpleForm::MapType
  # @raise [ArgumentError]
  def map_type(*types); end

  class << self
    # @private
    def extended(base); end
  end
end

class SimpleForm::Railtie < ::Rails::Railtie; end
module SimpleForm::Tags; end

class SimpleForm::Tags::CollectionCheckBoxes < ::ActionView::Helpers::Tags::CollectionCheckBoxes
  include ::SimpleForm::Tags::CollectionExtensions

  def render; end

  private

  def render_component(builder); end
end

module SimpleForm::Tags::CollectionExtensions
  private

  def render_collection; end
  def wrap_rendered_collection(collection); end
end

class SimpleForm::Tags::CollectionRadioButtons < ::ActionView::Helpers::Tags::CollectionRadioButtons
  include ::SimpleForm::Tags::CollectionExtensions

  def render; end

  private

  def render_component(builder); end
end

# Raised when fails to find a given wrapper name
class SimpleForm::WrapperNotFound < ::StandardError; end

module SimpleForm::Wrappers; end

# Provides the builder syntax for components. The builder provides
# three methods `use`, `optional` and `wrapper` and they allow the following invocations:
#
#     config.wrappers do |b|
#       # Use a single component
#       b.use :html5
#
#       # Use the component, but do not automatically lookup. It will only be triggered when
#       # :placeholder is explicitly set.
#       b.optional :placeholder
#
#       # Use a component with specific wrapper options
#       b.use :error, wrap_with: { tag: "span", class: "error" }
#
#       # Use a set of components by wrapping them in a tag+class.
#       b.wrapper tag: "div", class: "another" do |ba|
#         ba.use :label
#         ba.use :input
#       end
#
#       # Use a set of components by wrapping them in a tag+class.
#       # This wrapper is identified by :label_input, which means it can
#       # be turned off on demand with `f.input :name, label_input: false`
#       b.wrapper :label_input, tag: "div", class: "another" do |ba|
#         ba.use :label
#         ba.use :input
#       end
#     end
#
# The builder also accepts default options at the root level. This is usually
# used if you want a component to be disabled by default:
#
#     config.wrappers hint: false do |b|
#       b.use :hint
#       b.use :label_input
#     end
#
# In the example above, hint defaults to false, which means it won't automatically
# do the lookup anymore. It will only be triggered when :hint is explicitly set.
class SimpleForm::Wrappers::Builder
  # @return [Builder] a new instance of Builder
  def initialize(options); end

  def optional(name, options = T.unsafe(nil), &block); end
  def to_a; end
  def use(name, options = T.unsafe(nil)); end
  def wrapper(name, options = T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Leaf
  # @return [Leaf] a new instance of Leaf
  def initialize(namespace, options = T.unsafe(nil)); end

  def find(name); end

  # Returns the value of attribute namespace.
  def namespace; end

  def render(input); end
end

# A wrapper is an object that holds several components and render them.
# A component may be any object that responds to `render`.
# This API allows inputs/components to be easily wrapped, removing the
# need to modify the code only to wrap input in an extra tag.
#
# `Many` represents a wrapper around several components at the same time.
# It may optionally receive a namespace, allowing it to be configured
# on demand on input generation.
class SimpleForm::Wrappers::Many
  # @return [Many] a new instance of Many
  def initialize(namespace, components, defaults = T.unsafe(nil)); end

  # Returns the value of attribute components.
  def components; end

  # Returns the value of attribute defaults.
  def defaults; end

  def find(name); end

  # Returns the value of attribute namespace.
  def namespace; end

  def render(input); end

  private

  def html_classes(input, options); end
  def html_options(options); end
  def wrap(input, options, content); end
end

# `Root` is the root wrapper for all components. It is special cased to
# always have a namespace and to add special html classes.
class SimpleForm::Wrappers::Root < ::SimpleForm::Wrappers::Many
  # @return [Root] a new instance of Root
  def initialize(*args); end

  # Provide a fallback if name cannot be found.
  def find(name); end

  # Returns the value of attribute options.
  def options; end

  def render(input); end

  private

  def html_class(key, options); end
  def html_classes(input, options); end
end

# `Single` is an optimization for a wrapper that has only one component.
class SimpleForm::Wrappers::Single < ::SimpleForm::Wrappers::Many
  # @return [Single] a new instance of Single
  def initialize(name, wrapper_options = T.unsafe(nil), options = T.unsafe(nil)); end

  def render(input); end

  private

  def html_options(options); end
end
